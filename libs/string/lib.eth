
--------------------------------------------------------------------------------
--                                Strings
-- Constructors:
-- * format
-- * cat (C)
-- * join
--
-- Miscelenious:
-- * len (C)
-- * to_upper (C)
-- * to_lower (C)
-- * chr (C)
-- * ord (C)
-- * to_number (C)
-- * to_symobl (C)
--
-- Stripping:
-- * chomp (C)
-- * chop (C)
--
-- Slicing (C):
-- * sub
--
-- Comparison:
-- * cmp (C)
-- * casecmp (C)
--
-- Searching:
-- * find
let pub join sep xs =
  if xs is nil then ""
  else if let hd::[] = xs then hd
  else if let hd::tl = xs then
    List.fold_left (fn x y -> cat [x, sep, y]) hd tl
  else invalid_argument ()
in
let pub sub s x =
  if let l .. r = x then __substr s l (r - l + 1)
  else if let l... = x then __substr s l (len s - l)
  else if let ...r = x then __substr s 0 (r + 1)
  else fn y -> __substr s x y;
in

--------------------------------------------------------------------------------
--                                Regexp
-- * match (C)
-- * rev_split (C)
-- * split
let pub split re str = List.rev $ rev_split re str in

let pub find_opt pat s =
  if regexp? pat then __find_regexp pat s
  else if string? pat then __strstr_opt s pat
  else type_error ()
in
let pub find pat s =
  if let Some x = find_opt pat s then x
  else failure ()
in

nil
