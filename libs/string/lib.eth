--------------------------------------------------------------------------------
--                                Strings
-- Constructors:
-- * cat (C)
-- * join
-- * create
-- * make (C)
--
-- Miscelenious:
-- * len (C)
-- * to_upper (C)
-- * to_lower (C)
-- * chr (C)
-- * ord (C)
-- * to_number (C)
-- * to_symobl (C)
--
-- Stripping:
-- * chomp (C)
-- * chop (C)
--
-- Element access (C):
-- * sub
-- * get
--
-- Comparison:
-- * cmp (C)
-- * casecmp (C)
--
-- Searching:
-- * find
--

let pub create =
{.help|
= String.create

== DESCRIPTION:
Create an uninitialized string of given length.

== SYNOPSIS

  create number? -> string?
|.help}
  __create

let pub make =
{.help|
= String.make

== DESCRIPTION
Create  a  string of given length filled with a first  character  of  supplied
string. If it is of zero length, then the it is treated as 0-byte.

== SYNOPSIS

  make number? string? -> string?

|.help}
  __make

-- TODO: optimize
let pub rev s =
  list s |> List.rev |> cat

let pub join sep xs =
  if xs is nil then ""
  else if let hd::[] = xs then hd
  else if let hd::tl = xs then
    List.fold_left (fn x y -> cat [x, sep, y]) hd tl
  else invalid_argument ()

let pub sub x s =
  if let l .. r = x then __substr s l (r - l + 1)
  else if let l... = x then __substr s l (len s - l)
  else if let ...r = x then __substr s 0 (r + 1)
  else invalid_argument ()

let pub get i s = __substr s i 1

--------------------------------------------------------------------------------
--                                Regexp
-- * match (C)
-- * rev_split (C)
-- * split
-- * gsub
let pub split re str = List.rev $ rev_split re str

let pub find pat s =
  if regexp? pat then __find_regexp pat s
  else if string? pat then
    if let Some start = __strstr_opt s pat
    then (start, start + len pat)
    else false
  else type_error ()

