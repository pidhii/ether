let pub __builtin (+) x y = x + y in
let pub __builtin (-) x y = x - y in
let pub __builtin (*) x y = x * y in
let pub __builtin (/) x y = x / y in
let pub __builtin (mod) x y = x mod y in
let pub __builtin (^) x y = x ^ y in

let pub __builtin (land) x y = x land y in
let pub __builtin (lor) x y = x lor y in
let pub __builtin (lxor) x y = x lxor y in
let pub __builtin (lshl) x y = x lshl y in
let pub __builtin (lshr) x y = x lshr y in
let pub __builtin (ashl) x y = x ashl y in
let pub __builtin (ashr) x y = x ashr y in
let pub __builtin (lnot) x = lnot x in

let pub __builtin (<) x y = x < y in
let pub __builtin (>) x y = x > y in
let pub __builtin (<=) x y = x <= y in
let pub __builtin (>=) x y = x >= y in
let pub __builtin (==) x y = x == y in
let pub __builtin (/=) x y = x /= y in

let pub __builtin (is) x y = x is y in

let pub __builtin (::) x y = x :: y in
let pub (++) x y = x ++ y in

let pub __builtin (not) x = not x in

let pub (âˆ˜) f g x = f (g x) in

(* Application *)
let pub ($) f x = f x in
let pub (|>) x f = f x in

(* Pairs *)
let pub car (x::_) = x in
let pub cdr (_::x) = x in

(* Tuples *)
let pub first  {_1 = x} = x in
let pub second {_2 = x} = x in
let pub third  {_3 = x} = x in

(* Functions *)
let pub id x = x in

let pub flip f x y = f y x in
let pub const x = fn _ -> x in
let pub curry f = fn x y -> f (x, y) in
let pub uncurry f = fn (x, y) -> f x y in

(* Math *)
let pub even? x = x mod 2 == 0 in
let pub odd?  x = x mod 2 == 1 in

(*let ( *<< ) f g = *)
let compose_va f g =
  let rec aux x =
    if function? x then
      fn y -> aux (x y)
      (*x >> aux *)
    else f x
  in aux g
in
(*let ( >>* ) = flip ( <<* ) in *)

(* ><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><
 *                                   IO
 * -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 * - open_in
 * - open_out
 * - open_append
 * - open_pipe_in
 * - open_pipe_out
 * - close (C)
 *
 * Input:
 * - input (C)
 * - read_of (C)
 * - read
 * - read_line_of (C)
 * - read_line
 * - read_file (C)
 *
 * Output:
 * - print (C)
 * - print_to
 * - newline (C)
 * - write_to (C)
 * - write
 * - printf
 * - eprintf
 *
 * Miscelenious:
 * - tell (C)
 * - seek (C)
 *)
let pub open_in path = __open path "r" in
let pub open_out path = __open path "w" in
let pub open_append path = __open path "a" in
let pub open_pipe_in cmd = __popen cmd "r" in
let pub open_pipe_out cmd = __popen cmd "w" in

let pub read_line! = read_line_of stdin in
let pub read! = read_of stdin in

let pub print_to file x =
  if tuple? x then
    let hd :: tl = list x in
    write_to file (format "~d" hd);
    let rec loop xs =
      if let x :: xs = xs then
        write_to file (format "\t~d" x);
        loop xs
      else write_to file "\n";
    in loop tl
  else
    write_to file (format "~d\n" x)
in
let pub write = write_to stdout in
let pub printf = __printf stdout in
let pub fprintf file = compose_va (write_to file) format in
let pub eprintf = __printf stderr in

let pub seek file pos =
  let (offs, whence) =
    if let Set x = pos then (x, 0)
    else if let Cur x = pos then (x, 1)
    else if let End x = pos then (x, 2)
    else raise Invalid_argument
  in __seek file offs whence
in

(* ><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><+><
 *                                System
 * -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 *)
let pub system = compose_va __system format in
(*let pub system = __system <<* format in *)


()

