module =

let pub __builtin (+) x y = x + y
let pub __builtin (-) x y = x - y
let pub __builtin (*) x y = x * y
let pub __builtin (/) x y = x / y
let pub __builtin (mod) x y = x mod y
let pub __builtin (^) x y = x ^ y

let pub __builtin (land) x y = x land y
let pub __builtin (lor) x y = x lor y
let pub __builtin (lxor) x y = x lxor y
let pub __builtin (lshl) x y = x lshl y
let pub __builtin (lshr) x y = x lshr y
let pub __builtin (ashl) x y = x ashl y
let pub __builtin (ashr) x y = x ashr y
let pub __builtin (lnot) x = lnot x

let pub __builtin (<) x y = x < y
let pub __builtin (>) x y = x > y
let pub __builtin (<=) x y = x <= y
let pub __builtin (>=) x y = x >= y
let pub __builtin (==) x y = x == y
let pub __builtin (/=) x y = x /= y

let pub __builtin (is) x y = x is y

let pub __builtin (::) x y = x :: y
let pub (++) x y = x ++ y

let pub __builtin (not) x = not x

let pub (âˆ˜) f g x = f (g x)

-- Application
let pub ($) f x = f x
let pub (|>) x f = f x

-- Pairs
let pub car (x::_) = x
let pub cdr (_::x) = x

-- Tuples
let pub first  {_1 = x} = x
let pub second {_2 = x} = x
let pub third  {_3 = x} = x

-- Functions
let pub id x = x

let pub flip f x y = f y x
let pub const x = fn _ -> x
let pub curry f = fn x y -> f (x, y)
let pub uncurry f = fn (x, y) -> f x y

-- Math
let pub even? x = x mod 2 == 0
let pub odd?  x = x mod 2 == 1

--let ( *<< ) f g =
let compose_va f g =
  let rec aux x =
    if function? x then
      fn y -> aux (x y)
      --x >> aux
    else f x
  in aux g
--let ( >>* ) = flip ( <<* ) in

let pub die msg =
  __printf stderr "~d\n" msg;
  exit 1


let pub create_env defs =
  { defs, load = fn {defs} path -> __builtin_load path defs }
let pub load path = __builtin_load path []

--------------------------------------------------------------------------------
--                                   IO
--
-- * open_in
-- * open_out
-- * open_append
-- * open_pipe_in
-- * open_pipe_out
-- * close (C)
--
-- Input:
-- * input (C)
-- * read_of (C)
-- * read
-- * read_line_of (C)
-- * read_line_of_opt
-- * read_line
-- * read_line_opt
-- * read_file (C)
--
-- Output:
-- * print (C)
-- * print_to
-- * newline (C)
-- * write_to (C)
-- * write
-- * printf
-- * eprintf
--
-- Miscelenious:
-- * tell (C)
-- * seek (C)
let pub open_in path = __open path "r"
let pub open_out path = __open path "w"
let pub open_append path = __open path "a"
let pub open_pipe_in cmd = __popen cmd "r"
let pub open_pipe_out cmd = __popen cmd "w"

let pub read_line! = read_line_of stdin
let pub read_line_opt! = try Some read_line!  with End_of_file -> false
let pub read_line_of_opt file = try Some (read_line_of file) with End_of_file -> false

let pub read = read_of stdin
let pub read_opt n = try Some (read n) with End_of_file -> false
let pub read_of_opt file n = try Some (read_of file n) with End_of_file -> false

let pub print_to file x =
  if tuple? x then
    let hd :: tl = list x in
    write_to file (format "~d" hd);
    let rec loop xs =
      if let x :: xs = xs then
        write_to file (format "\t~d" x);
        loop xs
      else write_to file "\n";
    in loop tl
  else
    write_to file (format "~d\n" x)

let pub write = write_to stdout
let pub printf = __printf stdout
let pub fprintf file = compose_va (write_to file) format
let pub eprintf = __printf stderr

let pub seek file pos =
  let (offs, whence) =
    if let Set x = pos then (x, 0)
    else if let Cur x = pos then (x, 1)
    else if let End x = pos then (x, 2)
    else raise Invalid_argument
  in __seek file offs whence

--------------------------------------------------------------------------------
--                                System
let pub system = compose_va __system format
--let pub system = __system <<* format in

let pub shell =
  let aux cmd =
    let pipe = open_pipe_in cmd in
    let rec loop acc =
      if let Some data = read_of_opt pipe 0x100
        then loop (acc ++ data)
        else acc
    in
    loop ""
  in
  compose_va aux format

--------------------------------------------------------------------------------
--                                Errors
--
let pub failure () = raise Failure
let pub invalid_argument () = raise Invalid_argument
let pub type_error () = raise Type_error

end -- module
