
open 'string'

--------------------------------------------------------------------------------
-- Functions:
-- * chdir
-- * access
-- * getcwd
-- * realpath
--
-- Values:
-- * f_ok, r_ok, w_ok, x_ok

let pub f_ok = __f_ok
let pub r_ok = __r_ok
let pub w_ok = __w_ok
let pub x_ok = __x_ok

let pub o_cloexec = __o_cloexec
let pub o_direct = __o_direct
let pub o_nonblock = __o_nonblock

let pub chdir(dir) -> (
  try __chdir(dir)
  with errno -> raise(SystemError(errno))
)

let pub access(path, amode) -> (
  {help|
  = Os.access

  == SYNOPSIS

    access <path> <amode> -> boolean?

  == DESCRIPTION
  The function shall chek the file named by  the  pathname  (possibly  relative)
  _path_ for acessibility according to the bit pattern specified in _amode_.

  The value of _amode_  is either the bitwise-inclusive OR of \`r_ok`, \`w_ok`, \`x_ok` or existence test, \`f_ok`.

  See also man(3) access for complete documentation.
  |help}
  try __access(path, amode)
  with errno -> raise(SystemError(errno))
)

let pub getcwd() -> (
  try __getcwd()
  with errno -> raise(SystemError(errno))
)

let pub getenv = __getenv

let pub setenv(name, value, overwrite) -> (
  try __setenv(name, value, overwrite)
  with errno -> raise(SystemError(errno))
)

let pub unsetenv(name) -> (
  try __unsetenv(name)
  with errno -> raise(SystemError(errno))
)

let fix_path(path) -> (
  if (substr(path, 0 .. 1, path) eq "~/") or false
  then getenv("HOME") ++ substr(1..*, path)
  else path
)
let pub realpath(path) -> (
  try __realpath(fix_path(path))
  with errno -> raise(SystemError(errno))
)

let pub mkdtemp(temp) -> (
  {help|
  = Os.mkdtemp

  == Synopsis

    mkdtemp <template-string> -> string?

  == DESCRIPTION
  Create temporary directory with name created from _template-string_  and  return
  obtained path.

  ==== ARGUMENTS
  - _emplate-string_: Template path for the directory ending with six 'X' characters.
  |help}
  try __mkdtemp(temp)
  with errno -> raise(SystemError(errno))
)

let pub fork() -> (
  try __fork()
  with errno -> raise(SystemError(errno))
)

let pub waitpid(pid, opts) -> (
  try __waitpid(pid, opts)
  with errno -> raise(SystemError(errno))
)

let pub pipe() -> (
  try __pipe()
  with errno -> raise(SystemError(errno))
)

let pub pipe2(flags) -> (
  try __pipe2(flags)
  with errno -> raise(SystemError(errno))
)

let pub fileno(file) -> (
  try __fileno(file)
  with errno -> raise(SystemError(errno))
)

