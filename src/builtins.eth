
let pub car x:_ = x in
let pub cdr _:x = x in

let pub (+) x y = x + y in
let pub (-) x y = x - y in
let pub (*) x y = x * y in
let pub (/) x y = x / y in
let pub (mod) x y = x mod y in
let pub (^) x y = x ^ y in

let pub (land) x y = x land y in
let pub (lor) x y = x lor y in
let pub (lxor) x y = x lxor y in
let pub (lshl) x y = x lshl y in
let pub (lshr) x y = x lshr y in
let pub (ashl) x y = x ashl y in
let pub (ashr) x y = x ashr y in
let pub (lnot) x = lnot x in

let pub (<) x y = x < y in
let pub (>) x y = x > y in
let pub (<=) x y = x <= y in
let pub (>=) x y = x >= y in
let pub (==) x y = x == y in
let pub (/=) x y = x /= y in

let pub (is) x y = x is y in

let pub (:) x y = x : y in
let pub (++) x y = x ++ y in

let pub (not) x = not x in

let pub ($) f x = f x in
let pub (|>) x f = f x in


let pub id x = x in
let pub flip f x y = f y x in
let pub const x = fn -> x in
let pub curry f = fn x y -> f (x, y) in
let pub uncurry f = fn (x, y) -> f x y in

let pub even? x = x mod 2 == 0 in
let pub odd?  x = x mod 2 == 1 in

let pub __builtin_inclusive_range from to =
  let rec loop i acc =
    if i < from then acc
    else loop (i - 1) (i : acc)
  in loop to nil
in

################################################################################
#                                  IO
#-------------------------------------------------------------------------------
# - open
# - open_pipe
# - close
#
# Input:
# - input
# - read_of
# - read
# - read_line_of
# - read_line
# - read_file
#
# Output:
# - print
# - newline
# - printf
# - write_to
# - write
#
# Miscelenious:
# - tell
# - seek
#
let pub open x =
  if string? x then __open x "r"
  else if let (p, m) = x then __open p m
  else raise Invalid_argument
in

let pub open_pipe x =
  if string? x then __open_pipe x "r"
  else if let (c, m) = x then __open_pipe c m
  else raise Invalid_argument
in

let pub read_line! = read_line_of stdin in
let pub read! = read_of stdin in

let pub write = write_to stdout in

#let pub seek file pos = match pos with
#| Set: k -> __builtin_seek file k 0
#| Cur: k -> __builtin_seek file k 1
#| End: k -> __builtin_seek file k 2
#in

let pub seek file (pos:offs) =
  let whence =
    if pos is Set then 0 else
    if pos is Cur then 1 else
    if pos is End then 2 else
    raise Invalid_argument
  in __seek file offs whence
in

################################################################################
#                                 System
#-------------------------------------------------------------------------------

let pub system fmt =
  let rec aux x =
    if not function? x then
      __system x
    else fn y -> aux (x y)
  in aux (format fmt)
in

#let (*>>) f g =
  #let rec aux x =
    #if function? x then
      #x >> aux
    #else f x
  #in aux g
#in

#let (<<*) = flip (>>*) in

#let pub system = __system <<* format in

################################################################################
#                                 String
#-------------------------------------------------------------------------------
# Constructors:
# - concat (C)
#
# Miscelenious:
# - strlen (C)
# - to_upper (C)
# - to_lower (C)
# - chr (C)
# - ord (C)
#
# Stripping:
# - chomp (C)
# - chop (C)
#
# Slicing (C):
# - substr
#
# Comparison:
# - strcmp (C)
# - strcasecmp (C)
#

################################################################################
#                                  List
#-------------------------------------------------------------------------------
# Constructors:
# - range
#
# Miscelenious:
# - rev_append (C)
# - rev
# - append
# - flatten
# - length (C)
#
# Iterators:
# - rev_map
# - map
# - for_each
# - rev_flat_map
# - flat_map
# - rev_filter_map
# - filter_map
# - fold_left
# - fold_right
# - scan_left
# - scan_right
#
# Slicing:
# - rev_take
# - take
# - drop
#
# Scanning:
# - all?
# - any?
# - memq?
#
# Searching:
# - rev_filter
# - filter
# - find
# - partition
#
# Sorting:
# - merge
# - sort
#

let pub range from to =
  let rec loop i acc =
    if i < from then acc
    else loop (i - 1) (i : acc)
  in loop (to - 1) nil
in

let pub rev xs = rev_append xs nil in

let rec pub append xs ys =
  if let x:xs = xs then
    x : append xs ys
  else ys
in

let pub rev_map f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (f x : acc)
    else acc
  in loop xs nil
in
let pub map f xs = rev $ rev_map f xs in

let rec pub for_each f xs =
  when let x:xs = xs then (
    f x;
    for_each f xs
  )
in

let rec pub rev_flat_map f xs =
  let rec loop ys xs acc =
    if let y:ys = ys then
      loop ys xs (y : acc)
    else if let x:xs = xs then
      loop (f x) xs acc
    else acc
  in loop nil xs nil
in
let rec pub flat_map f xs =
  if let x:xs = xs then
    if xs is nil then f x
    else append (f x) (flat_map f xs)
  else nil
in

let pub rev_filter_map f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (try (f x : acc) with Filter_out -> acc)
    else acc
  in loop xs nil
in
let pub filter_map f xs = rev $ rev_filter_map f xs in

let pub fold_left f z xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (f acc x)
    else acc
  in loop xs z
in

let rec pub fold_right f z xs =
  if let x:xs = xs then
    f x (fold_right f z xs)
  else z
in

let rec pub scan_left f z xs =
  if let x:xs = xs then
    let z = f z x in
    z : scan_left f z xs
  else nil
in

let rec pub scan_right f z xs =
  if let x:xs = xs then
    if let z:_ as tl = scan_right f z xs then
      f x z : tl
    else [f x z]
  else nil
in

let pub rev_filter f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (if f x then x : acc else acc)
    else acc
  in loop xs nil
in

let pub filter f xs = rev $ rev_filter f xs in

let pub flatten = flat_map id in

let rec pub find p xs =
  if let x:xs = xs then
    if p x then x
    else find p xs
  else raise Not_found
in

let pub merge cmp xs ys =
  let rec loop xs ys acc =
    if let x:xs' = xs then
      if let y:ys' = ys then
        if cmp x y
        then loop xs' ys  (x:acc)
        else loop xs  ys' (y:acc)
      else rev_append acc xs
    else rev_append acc ys
  in loop xs ys nil
in

let split_by_half =
  let rec loop slow fast acc =
    if let _:_:fast = fast then
      let x:slow = slow in
      loop slow fast (x:acc)
    else (acc, slow)
  in fn xs -> loop xs xs nil
in

let rec pub sort cmp xs =
  if let _:_:_ = xs then
    let (l, r) = split_by_half xs in
    merge cmp (sort cmp l) (sort cmp r)
  else xs
in

let pub partition p xs =
  let rec loop xs acc1 acc2 =
    if let x:xs = xs then
      if p x
      then loop xs (x : acc1) acc2
      else loop xs acc1 (x : acc2)
    else (rev acc1, rev acc2)
  in loop xs [] []
in

let rec pub rev_take =
  let rec loop n xs acc =
    if n > 0 then
      let x:xs = xs in
      loop (n - 1) xs (x : acc)
    else acc
  in fn n xs -> loop n xs []
in

let rec pub take n xs =
  if n > 0 then
    let x:xs = xs in
    x : take (n - 1) xs
  else []
in

let rec pub drop n xs =
  if n > 0 then
    drop (n - 1) (cdr xs)
  else xs
in

let rec pub all? p xs =
  if let x:xs = xs then
    p x && all? p xs
  else true
in

let rec pub any? p xs =
  if let x:xs = xs then
    p x || any? p xs
  else false
in

let rec pub memq? a xs =
  if let x:xs = xs then
    x is a || memq? a xs
  else false
in

()

