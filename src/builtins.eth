let pub __builtin (+) x y = x + y in
let pub __builtin (-) x y = x - y in
let pub __builtin (*) x y = x * y in
let pub __builtin (/) x y = x / y in
let pub __builtin (mod) x y = x mod y in
let pub __builtin (^) x y = x ^ y in

let pub __builtin (land) x y = x land y in
let pub __builtin (lor) x y = x lor y in
let pub __builtin (lxor) x y = x lxor y in
let pub __builtin (lshl) x y = x lshl y in
let pub __builtin (lshr) x y = x lshr y in
let pub __builtin (ashl) x y = x ashl y in
let pub __builtin (ashr) x y = x ashr y in
let pub __builtin (lnot) x = lnot x in

let pub __builtin (<) x y = x < y in
let pub __builtin (>) x y = x > y in
let pub __builtin (<=) x y = x <= y in
let pub __builtin (>=) x y = x >= y in
let pub __builtin (==) x y = x == y in
let pub __builtin (/=) x y = x /= y in

let pub __builtin (is) x y = x is y in

let pub __builtin (:) x y = x : y in
let pub (++) x y = x ++ y in

let pub __builtin (not) x = not x in

let pub ($) f x = f x in
let pub (|>) x f = f x in

let pub car x:_ = x in
let pub cdr _:x = x in

let pub id x = x in
let pub flip f x y = f y x in
let pub const x = fn -> x in
let pub curry f = fn x y -> f (x, y) in
let pub uncurry f = fn (x, y) -> f x y in

let pub even? x = x mod 2 == 0 in
let pub odd?  x = x mod 2 == 1 in

let pub __builtin_inclusive_range from to =
  let rec loop i acc =
    if i < from then acc
    else loop (i - 1) (i : acc)
  in loop to nil
in

#let (*<<) f g =
let compose_va f g =
  let rec aux x =
    if function? x then
      fn y -> aux (x y)
      #x >> aux
    else f x
  in aux g
in
#let (>>*) = flip (<<*) in

################################################################################
#                                  IO
#-------------------------------------------------------------------------------
# - open_in
# - open_out
# - open_append
# - open_pipe (C)
# - close (C)
#
# Input:
# - input (C)
# - read_of (C)
# - read
# - read_line_of (C)
# - read_line
# - read_file (C)
#
# Output:
# - print (C)
# - newline (C)
# - printf (C)
# - write_to (C)
# - write
#
# Miscelenious:
# - tell (C)
# - seek (C)
#
let pub open_in path = __open path "r" in
let pub open_out path = __open path "w" in
let pub open_append path = __open path "a" in
let pub open_pipe_in = compose_va (fn cmd -> __popen cmd "r") format in
let pub open_pipe_out = compose_va (fn cmd -> __popen cmd "w") format in

let pub read_line! = read_line_of stdin in
let pub read! = read_of stdin in

let pub write = write_to stdout in

let pub seek file (pos:offs) =
  let whence =
    if pos is Set then 0 else
    if pos is Cur then 1 else
    if pos is End then 2 else
    raise Invalid_argument
  in __seek file offs whence
in
#let pub seek file pos = match pos with
#| Set: k -> __builtin_seek file k 0
#| Cur: k -> __builtin_seek file k 1
#| End: k -> __builtin_seek file k 2
#in

################################################################################
#                                 System
#-------------------------------------------------------------------------------

let pub system = compose_va __system format in
#let pub system = __system <<* format in

################################################################################
#                                 String
#-------------------------------------------------------------------------------
# Constructors:
# - concat (C)
#
# Miscelenious:
# - strlen (C)
# - to_upper (C)
# - to_lower (C)
# - chr (C)
# - ord (C)
#
# Stripping:
# - chomp (C)
# - chop (C)
#
# Slicing (C):
# - substr
#
# Comparison:
# - strcmp (C)
# - strcasecmp (C)
#

################################################################################
#                                  List
#-------------------------------------------------------------------------------
# Constructors:
# - range
#
# Miscelenious:
# - rev_append (C)
# - rev
# - append
# - flatten
# - length (C)
#
# Iterators:
# - rev_map
# - map
# - zip
# - for_each
# - rev_flat_map
# - flat_map
# - rev_filter_map
# - filter_map
# - fold_left
# - fold_right
# - scan_left
# - scan_right
#
# Slicing:
# - rev_take
# - take
# - drop
#
# Scanning:
# - all?
# - any?
# - memq?
#
# Searching:
# - rev_filter
# - filter
# - find
# - partition
#
# Sorting:
# - merge
# - sort
#

let pub range from to =
  let rec loop i acc =
    if i < from then acc
    else loop (i - 1) (i : acc)
  in loop (to - 1) nil
in

let pub rev xs = rev_append xs nil in

let rec pub append xs ys =
  if let x:xs = xs then
    x : append xs ys
  else ys
in

let pub rev_map f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (f x : acc)
    else acc
  in loop xs nil
in
let pub map f xs = rev $ rev_map f xs in

let rec pub rev_zip f xs ys =
  let rec loop xs ys acc =
    if let x:xs = xs then
      if let y:ys = ys then
        loop xs ys (f x y : acc)
      else acc
    else acc
    #match xs, ys with
    #| x:xs, y:ys -> loop xs ys (f x y : acc)
    #| otherwize  -> acc
  in loop xs ys []
in

let rec pub zip f xs ys =
  if let x:xs = xs then
    if let y:ys = ys then
      f x y : zip f xs ys
    else []
  else []
  #match xs, ys with
  #| x:xs, y:ys -> f x y : loop xs ys
  #| otherwize  -> []
in

let rec pub for_each f xs =
  when let x:xs = xs then (
    f x;
    for_each f xs
  )
in

let rec pub rev_flat_map f xs =
  let rec loop ys xs acc =
    if let y:ys = ys then
      loop ys xs (y : acc)
    else if let x:xs = xs then
      loop (f x) xs acc
    else acc
  in loop nil xs nil
in
let rec pub flat_map f xs =
  if let x:xs = xs then
    if xs is nil then f x
    else append (f x) (flat_map f xs)
  else nil
in

let pub rev_filter_map f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (try (f x : acc) with Filter_out -> acc)
    else acc
  in loop xs nil
in
let pub filter_map f xs = rev $ rev_filter_map f xs in

let pub fold_left f z xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (f acc x)
    else acc
  in loop xs z
in

let rec pub fold_right f z xs =
  if let x:xs = xs then
    f x (fold_right f z xs)
  else z
in

let rec pub scan_left f z xs =
  if let x:xs = xs then
    let z = f z x in
    z : scan_left f z xs
  else nil
in

let rec pub scan_right f z xs =
  if let x:xs = xs then
    if let z:_ as tl = scan_right f z xs then
      f x z : tl
    else [f x z]
  else nil
in

let pub rev_filter f xs =
  let rec loop xs acc =
    if let x:xs = xs then
      loop xs (if f x then x : acc else acc)
    else acc
  in loop xs nil
in

let pub filter f xs = rev $ rev_filter f xs in

let pub flatten = flat_map id in

let rec pub find p xs =
  if let x:xs = xs then
    if p x then x
    else find p xs
  else raise Not_found
in

let pub merge cmp xs ys =
  let rec loop xs ys acc =
    if let x:xs' = xs then
      if let y:ys' = ys then
        if cmp x y
        then loop xs' ys  (x:acc)
        else loop xs  ys' (y:acc)
      else rev_append acc xs
    else rev_append acc ys
  in loop xs ys nil
in

let split_by_half =
  let rec loop slow fast acc =
    if let _:_:fast = fast then
      let x:slow = slow in
      loop slow fast (x:acc)
    else (acc, slow)
  in fn xs -> loop xs xs nil
in

let rec pub sort cmp xs =
  if let _:_:_ = xs then
    let (l, r) = split_by_half xs in
    merge cmp (sort cmp l) (sort cmp r)
  else xs
in

let pub partition p xs =
  let rec loop xs acc1 acc2 =
    if let x:xs = xs then
      if p x
      then loop xs (x : acc1) acc2
      else loop xs acc1 (x : acc2)
    else (rev acc1, rev acc2)
  in loop xs [] []
in

let rec pub rev_take =
  let rec loop n xs acc =
    if n > 0 then
      let x:xs = xs in
      loop (n - 1) xs (x : acc)
    else acc
  in fn n xs -> loop n xs []
in

let rec pub take n xs =
  if n > 0 then
    let x:xs = xs in
    x : take (n - 1) xs
  else []
in

let rec pub drop n xs =
  if n > 0 then
    drop (n - 1) (cdr xs)
  else xs
in

let rec pub all? p xs =
  if let x:xs = xs then
    p x && all? p xs
  else true
in

let rec pub any? p xs =
  if let x:xs = xs then
    p x || any? p xs
  else false
in

let rec pub memq? a xs =
  if let x:xs = xs then
    x is a || memq? a xs
  else false
in

let rec pub assoc x l =
  if let kv:l = l then
    if let (k, v) = kv then
      if k eq x then v
      else assoc x l
    else raise Invalid_argument
  else raise Not_found
in

let rec pub assq x l =
  if let kv:l = l then
    if let (k, v) = kv then
      if k is x then v
      else assoc x l
    else raise Invalid_argument
  else raise Not_found
in

()

