open List in

let _MODE =
  if member? "testmode" command_line
  then Test
  else Default
in


let fac =
  let rec loop x acc =
    if x == 0 then acc
    else loop (x - 1) (acc * x)
  in fn x -> loop x 1
in

print (1, 2, 3);

let l = 1::2::3::nil in
print ("l:", l);
print ("rev_append l 42:", rev_append l 42);
print ("map l (* 2):", map (fn x -> x * 2) l);

let rec even x =
  x == 0 || odd (x - 1)
and odd x =
  x /= 0 && even (x - 1)
in

print ("even 42:", even 42);
print ("even 13:", even 31);

print ("-1 ashl 2:", -1 ashl 2);
print (not 1);
print (not false);

print ("test hex:", 1 lshl 1 lxor 0x02);

let l = 1::2::3::nil in
print $ 2.3 mod 1;
print $ map (fn f -> f 2) $ map (mod) l;

print ("++:", "Hello" ++ " " ++ "World!");

print ("list:", [1,2,3,4,5,"fasdf",nil]);

begin
  try raise Test_error;
  with e1 -> (
    print ("handle first error:", e1);
    begin
      try raise Second_error;
      with Second_error -> print ("handle second error:", e1);
    end;
    print "done with errors";
  )
end or print "I failed =(";

let t = (A, B, C, D) in
print ("4-tuple:", t);
let (_, b, _, d) = t in
print ("b:", b);
print ("d:", d);

when _MODE is Default then begin
  try
    let a = String.to_number $ input "Enter a: " in
    let b = String.to_number $ input "Enter b: " in
    let name = input "Enter your name: " in
    print (name ++ ", a + b = ", a + b);
  with End_of_file ->
    print "Oh, fuck you, bastard.";
end;

print ("test tuple:", tuple? (A,B), tuple? ());

print ("test list:", list (A,B,C,D,E,F,G), list [1,2,3]);


let r = { name = "Ivan", email = "gamil.com", id = "pidhii" } in
print ("record:", r);
let { name = nam } = r in
print ("name:", nam);
print ("list record:", list r);

let head (x::_) = x in
print ("head:", head [A,B,C,D,E]);

print ("match NIL:", if let _::nil = id [1] then true else false);

print ("range:", [1..10]);
print ("flat-map:", [[1..3], [4..6], [7..9]] |> flatten);
begin
  try
    print ("flat-map:",
      fold_left (+) 0 $ flatten $ [[1..100], [101..1000], [1001..200000], [1]]);
  with Stack_overflow -> print "no-no-no";
end;

print ("list-comprehension:", [x + x | x <- [1..3], odd? x]);

print ("partition:", partition even? [0..9]);

print ("format:", format "~d + ~d = ~d" 1 2 (1+2));

newline!;
print "--- test string";
let str = "abCdefg" in
print ("  str:", str);
print ("  list:", list str);
print ("  cat:", String.cat $ list str);
print ("  strlen:", String.len str);
print ("  to_upper:", String.to_upper str);
print ("  to_lower:", String.to_lower str);
print String.("  str[case]cmp:", cmp str str, cmp str (to_upper str),
  casecmp str (to_upper str));
print ("  chr 0x61:", String.chr 0x61);


print ("eq:",
  [42, "string", Symbol, {name="Smoorf",color=Blue}, (0xFF,0x00,0x10)]
                            eq
  [42, "string", Symbol, {name="Smoorf",color=Blue}, (0xFF,0x00,0x10)]);


let elf? x =
  let file =
    if file? x then x else
    if string? x then open_in x else
    raise Invalid_argument
  in
  let oldpos = tell file in
  seek file (Set 0);
  let hdr = read_of file 4 in
  seek file (Set oldpos);
  hdr eq "\x7fELF";
in

when _MODE is Default then (
  let path = "Debug/install/bin/ether" in
  printf "elf? ~w: ~w\n" path (elf? path);
);

let path = "out.txt" in
let file = open_out path in
write_to file "Hello there!";
close file;
print ("out.txt:", read_file $ open_in path);
system "rm -v ~d" path ;

begin
  let list? x = x is nil || pair? x in

  let (+) x y =
    if number? x && number? y then x + y
    else if list? x && list? y then map2 (+) x y
    else raise Type_error
  in

  let l1 = [1,2,3] in
  let l2 = [0,2,4] in
  let l3 = l1 + l2 in
  print ("l1:", l1);
  print ("l2:", l2);
  print ("l3:", l3);
end;

print ("argv:", String.join ", " command_line);

let option = id (Some 42) in
print ("variant:", option);
let Some x = option in
print ("variant value:", x);

[0x61 .. 0x70] |> iteri (fn i x ->
  print (i, String.chr x)
);

print ("=~:", "as foo so do bar" =~ \foo/);

let [_0, foo, bar] = String.match \as\s+(\w+).*do\s+(\w+)/ "as foo so do bar" in
print (">~:");
print ("  _0:", _0);
print ("  foo:", foo);
print ("  bar:", bar);

let capitalize str =
  let c = String.sub str 0 1 in
  let rest = String.sub str (1 ...) in
  String.to_upper c ++ rest
in

let dog color =
  { color = capitalize color
  , say = fn self ->
      printf "~d dog says \"Wof!\"\n" self.color
  }
in

let cat color =
  { color = capitalize color
  , say = fn self ->
      printf "~d cat says \"Miau\"\n" self.color
  }
in

let d = dog "black" in
d.say d;



let struct = {foo = 0xF00, ba = {b = 0xB, a = 0xA}, r = R} in
print ("struct:", struct);
print ("struct.foo:", struct.foo);
let { ba } = struct in print ("struct.ba:", ba);
let { ba } = struct in print ("struct.ba:", ba);
--print ("struct.ba.b:", struct.ba.b);
--print ("struct.ba.a:", struct.ba.a);
--print ("struct.r:", struct.r);
--print ("struct.ba (second):", struct.ba);

print "------------- test lazy ----------------";
let x = lazy (print "calculation"; 42) in
print ("x:", x!);
print ("x:", x!);
print ("x:", x!);
print ("x:", x!);

13;
