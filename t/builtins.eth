
let test =
  let do_test name thunk =
    printf "- ~d " name;
    try
      if thunk! then (
        printf "\x1b[38;5;2;1m✓\x1b[0m\n";
        true;
      ) else (
        printf "\x1b[38;5;1;1m✗\x1b[0m\n";
        false;
      )
    with e -> (
      printf "\x1b[38;5;1;1m✗ (~w)\x1b[0m\n" e;
      false;
    )
  in

  let rec loop xs nok nfail =
    if let (name,thunk)::xs = xs then
      if do_test name thunk
      then loop xs (nok+1) nfail
      else loop xs nok (nfail+1)
    else (nok, nfail)
  in

  fn tests -> loop tests 0 0
in

let string_tests = [
  ("concat", fn -> concat ["a", "b", "c"] eq "abc"),
  ("concat_with", fn -> concat_with "," ["a", "b", "c"] eq "a,b,c"),
  ("chr", fn -> chr 0x61 eq "a"),
  ("ord", fn -> ord "a" eq 0x61),
  ("strlen", fn -> strlen "1234" == 4),
  ("to_upper", fn -> to_upper "AbcD" eq "ABCD"),
  ("to_lower", fn -> to_lower "AbcD" eq "abcd"),
  ("chomp", fn -> chomp "asd\n\n" eq "asd" && chomp "asd" eq "asd"),
  ("chop", fn -> chop "asd" eq "as" && chop "" eq ""),
  ("strcmp", fn -> strcmp "asdf" "asdf" == 0),
  ("strcasecmp", fn -> strcasecmp "asdf" "ASdF" == 0),
  ("strncmp", fn -> strncmp "asd2" "asdf" 3 == 0),
  ("strncasecmp", fn -> strncasecmp "asd2" "ASdF" 3 == 0),
  ("substr", fn ->
    let str = "Hello World!" in
    all? id [
      substr str 0 4 eq "Hell",
      substr str (6...) eq "World!",
      substr str (...4) eq "Hello",
      substr str (4..6) eq "o W"]),
  ("strstr", fn -> strstr "123456" "45" == 3)
]
in

let regexp_tests = [
  ("=~", fn -> "as foo so do bar" =~ \foo/),
  ("match", fn -> match \[^^]\K(\w+)\s+(\w)/ "a bu c" eq ["bu c", "bu", "c"]),
  ("gsub", fn -> gsub \\s+/ (const "-") "a   s f  f f   " eq "a-s-f-f-f-"),
  ("split", fn -> split \\s+/ "asd asdf asdf " eq ["asd", "asdf", "asdf", ""]),
]
in

let list_tests = [
  ("[..]", fn -> [1..10] eq [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
  ("[.|.,.]", fn -> [x | x <- [1..10], even? x] eq [2, 4, 6, 8, 10]),
  ("unfold_left", fn -> unfold_left (fn i -> (i+1, i) when i < 3) 1 eq [2, 1]),
  ("unfold_right", fn -> unfold_right (fn i -> (i, i+1) when i < 3) 1 eq [1, 2]),
  ("range", fn -> range (0..9) eq [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
  ("rev_append", fn -> rev_append [A, B, C] D eq C::B::A::D),
  ("rev", fn -> rev [A, B, C] eq [C, B, A]),
  ("append", fn -> append [A, B, C] D eq A::B::C::D),
  ("flatten", fn -> flatten [[A, B], [C, D], [E, F]] eq [A, B, C, D, E, F]),
  ("length", fn -> length [1, 2, 3, 4, 5] == 5 && length [] == 0),
  ("rev_map", fn -> rev_map ((+) 1) [1, 2, 3] eq [4, 3, 2]),
  ("map", fn -> map ((+) 1) [1, 2, 3] eq [2, 3, 4]),
  ("rev_mapi", fn -> rev_mapi (+) [1, 2, 3] eq [5, 3, 1]),
  ("mapi", fn -> mapi (+) [1, 2, 3] eq [1, 3, 5]),
  ("rev_zip", fn -> rev_zip (-) [1, 2, 3] [2, 1, 0] eq [3, 1, -1]),
  ("zip", fn -> zip (-) [1, 2, 3] [2, 1, 0] eq [-1, 1, 3]),
  ("rev_zipi", fn ->
    rev_zipi (fn i x y -> i + x - y) [1, 2, 3] [2, 1, 0] eq [5, 2, -1]),
  ("zipi", fn -> zipi (fn i x y -> i + x - y) [1, 2, 3] [2, 1, 0] eq [-1, 2, 5]),
  ("rev_flat_map", fn -> rev_flat_map (fn x -> [1..x-1]) [1, 2, 3] eq [2, 1, 1]),
  ("flat_map", fn -> flat_map (fn x -> [1..x-1]) [1, 2, 3] eq [1, 1, 2]),
  ("rev_filter_map", fn ->
    let f x = x + x if even? x else raise Filter_out in
    rev_filter_map f [1, 2, 3, 4] eq [8, 4]),
  ("filter_map", fn ->
    let f x = x + x if even? x else raise Filter_out in
    filter_map f [1, 2, 3, 4] eq [4, 8]),
  ("fold_left", fn -> fold_left (-) 0 [1, 2, 3] == -6),
  ("fold_right", fn -> fold_right (-) 0 [1, 2, 3] == 2),
  ("scan_left", fn -> scan_left (-) 0 [1, 2, 3] eq [-1, -3, -6]),
  ("scan_right", fn -> scan_right (-) 0 [1, 2, 3] eq [2, -1, 3]),
  ("rev_take", fn -> rev_take 3 [1, 2, 3, 4, 5] eq [3, 2, 1]),
  ("take", fn -> take 3 [1, 2, 3, 4, 5] eq [1, 2, 3]),
  ("drop", fn -> drop 3 [1, 2, 3, 4, 5] eq [4, 5]),
  ("all?", fn -> all? even? [2, 4, 6] && not all? odd? [1, 8] && all? id []),
  ("any?", fn -> any? even? [1, 4, 3] && not any? odd? [2, 8] && not any? id []),
  ("member?", fn -> member? 3 [1, 2, 3, 4] && not member? 3 [1, 2, 4]),
  ("memq?", fn -> memq? C [A, B, C, D] && not memq? C [A, B, D]),
  ("rev_filter", fn -> rev_filter odd? [1, 2, 3] eq [3, 1]),
  ("filter", fn -> filter odd? [1, 2, 3] eq [1, 3]),
  ("remove", fn -> remove even? [1, 2, 3, 4] eq [1, 3, 4]),
  ("insert", fn -> insert (<) 3 [1, 2, 4, 5] eq [1, 2, 3, 4, 5]),
  ("find", fn ->
    let t1 = find even? [1, 2, 3] eq Some 2 in
    let t2 = not find even? [1, 3] in
    t1 && t2),
  ("partition", fn -> partition odd? [1, 2, 3] eq ([1, 3], [2])),
  ("merge", fn -> merge (<) [2, 4, 5] [1, 3, 5, 6] eq [1, 2, 3, 4, 5, 5, 6]),
  ("sort", fn -> sort (<) [1, 4, 7, 4, 3, 2, 5] eq [1, 2, 3, 4, 4, 5, 7]),
  ("assoc", fn ->
    let t1 = assoc "b" [("a", 1), ("b", 2), ("c", 3)] eq Some 2 in
    let t2 = not assoc "b" [("a", 1), ("c", 3)] in
    t1 && t2),
  ("assq", fn ->
    let t1 = assq B [(A, 1), (B, 2), (C, 3)] eq Some 2 in
    let t2 = not assq B [(A, 1), (C, 3)] in
    t1 && t2)
]
in

let sumres (nok, nfail) (nok', nfail') =
  (nok + nok', nfail + nfail')
in
let res = (0, 0) in

newline!;
printf "\x1b[1mTest string\x1b[0m\n";
let res = sumres res $ test string_tests in

newline!;
printf "\x1b[1mTest regexp\x1b[0m\n";
let res = sumres res $ test regexp_tests in

newline!;
printf "\x1b[1mTest list\x1b[0m\n";
let res = sumres res $ test list_tests in

newline!;
let (nok, nfail) = res in
printf "\x1b[1mSummary\x1b[0m\n";
printf "- succeed: \x1b[38;5;2;1m~d\x1b[0m\n" nok;
printf "- failed: \x1b[38;5;1;1m~d\x1b[0m\n" nfail;

newline!;

exit 1 when nfail > 0;

()

