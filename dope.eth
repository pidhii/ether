#!/bin/env ether

open IO
open String (chop, chomp, split, match, to_number)
open List (map, rev_filter_map, sort)

module Utl =
  -- Get direcory containing modules
  let pub module_path =
    let pipe = open_pipe_in "ether --prefix"
    let prefix = IO.read_line_of pipe |> String.chop
    if close pipe /= 0
    then raise Failed_to_resolve_prefix
    else prefix ++ "/lib/ether"

  -- Checks whether a file exists in the file system
  let pub exist? path =
    try Os.(access path f_ok)
    with System_error ENOENT -> false

  let pub mkdir path =
    unless system "mkdir -vp '{path}'" == 0
    then raise System_error

  let pub copy_file src dst =
    print "> copy \"{src}\" -> \"{dst}\""
    open_in src |> IO.read_file |> IO.write_to (open_out dst)

  let pub create_symlink src dst =
    unless system "ln -vs '{src}' '{dst}'" == 0
    then raise System_error

  let pub unlink path =
    unless system "rm -rfv '{path}'" == 0
    then raise System_error

  let pub unlink_quite path =
    unless system "rm -rf '{path}'" == 0
    then raise System_error

  let pub utc_date! =
    let pipe = open_pipe_in "date -u +'%x %X'"
    let line = IO.read_line_of pipe
    if close pipe /= 0
    then raise System_error
    else String.chop line

  let pub elf? path = IO.read_of (open_in path) 4 eq "\x7fELF"

  let pub do_in dir thunk =
    let cwd = Os.getcwd!
    Os.chdir dir
    try
      thunk!
    with e ->
      Os.chdir cwd
      raise e
    Os.chdir cwd

  let pub do_in_tempdir thunk =
    let cwd = Os.getcwd!

    let tempdir = Os.mkdtemp "/tmp/dope-tmp.XXXXXX"
    Os.chdir tempdir
    let cleanup! =
      unlink_quite tempdir
      Os.chdir cwd

    let thunk_result = try thunk! with e -> cleanup!; raise e
    cleanup!
    thunk_result


  let rec pub confirm? x =
    if let (prompt1, prompt2) = x then
      let rec loop ans =
        if ans =~ \[Yy](es)?/ then true
        else if ans =~ \[Nn]o?/ then false
        else loop (input prompt2)
      loop (input prompt1)
    else
      confirm? (x, "> try again (yes/no): ")
end
open Utl


module DB =
  open Utl
  using String as S
  using List as L

  let pub default_path = module_path ++ "/__db.eth"

  -- Get registry of installed modules
  let pub load path =
    { db = (first $ load path) if exist? path else []
    , path

    , get_module_opt = {db} name ->
        L.find_opt ({name = name'} -> S.casecmp name name' == 0) db

    , remove = fn ({db} as self) name ->
        {self with
          db = L.remove ({name = name'} -> S.casecmp name' name == 0) db
        }

    , add = fn ({db} as self) entry ->
        {self with db = entry :: db}

    , update = {db, path} ->
        let dbfile = open_out path
        IO.write_to dbfile (format "%w\n" db)
    }
end


module ModuleInfo =
  using String as S
  using List as L

  let pub get_versions repodir =
    -- Get all tags
    IO.shell "cd {repodir}; git tag" |> S.chop |> S.split \\s+/
    -- Decode version-tags into major, minor and a patch.
    |> L.rev_filter_map $ tag ->
      if let [_, major, minor, patch] = S.match \([0-9]+)\.([0-9]+)\.([0-9]+)/ tag then
        (tag, L.map S.to_number [major, minor, patch])
      else raise Filter_out
    -- Sort versions.
    |> L.sort $ (_, a) (_, b) ->
      let rec loop xs ys =
        if let x :: xs' = xs then
          if let y :: ys' = ys then
            if x > y then true
            else x == y && loop xs' ys'
          else true
        else true
      loop a b
    |> L.map first

  let pub load_config dir args =
    let _, conf =
      try
        let env = create_env [("command_line", args), ("root", dir)]
        env:load (dir ++ "/install.eth")
      with _ ->
        eprint "> error: failed to load install-script"
        raise Failure
    { name = L.assoc "name" conf
    , files = L.assoc "files" conf or []
    , main = L.assoc "main" conf
    , build = L.assoc_opt "build" conf
    , post_install = L.assoc_opt "post_install" conf
    }
end


module DBEntry =
  let pub empty = {
    name = nil,
    date = nil,
    install_dir = nil,
    repository = nil,
    version = nil,
  }
end


module Install =
  open Utl
  using List as L
  using String as S

  let pub build_and_install {conf, modentry, db, dir, args} =
    let {name, files, main, build, post_install} = conf

    -- Check if module name is unique
    print name
    when db:get_module_opt name then
      eprint "> error: module already present"
      raise Failure

    -- Build (if build-hook is speciefied)
    when let Some build = build then do_in dir $ fn ->
      print "> building module {name}"
      build!

    -- Start installation
    print "> installing module {name}"
    -- Create separate direcory for new module
    let moddir = module_path ++ "/" ++ name
    mkdir moddir
    -- Copy module sources
    main::files |> L.iter $ file ->
      copy_file (dir ++ "/" ++ file) (moddir ++ "/" ++ file)

    print "> all files copied"

    -- Create symlink to main
    let mainext = ".so" if elf? (dir ++ "/" ++ main) else ".eth"
    let mainpath = moddir ++ "/__main__" ++ mainext
    unless exist? mainpath then
      create_symlink (moddir ++ "/" ++ main) mainpath

    when let Some post_install = post_install then do_in dir $ fn ->
      print "> running post-install hooks"
      post_install!

    { modentry with name,
        date = utc_date! or "<undefined>",
        install_dir = Os.realpath moddir or "<undefined>",
    }
end


let uninstall name =
  let db = DB.(load default_path)

  if let Some {install_dir} = db:get_module_opt name then
    -- Remove module directory
    print "> uninstalling module '{name}'"
    unlink install_dir
    -- Update registry
    print "> updating registry"
    let db = db:remove name
    db:update
  else
    eprint "> error: no such module"
    raise Failure


let list_modules! =
  let {db} = DB.(load default_path)
  if db is [] then
    print "> no installed modules"
  else
    let f isfirst modentry =
      print "" unless isfirst
      list modentry |> List.iter $ (k, v) ->
        print "\e[4m{k}\e[0m: {v}"
      false
    List.fold_left f true db


let basename path =
  let [_, tail] = String.match \\/?([^\/]+)$/ path
  tail

let help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} COMMAND [OPTIONS]"
  print ""
  print "\e[1mCOMMANDS:\e[0m"
  print "  help      h           Show this message."
  print "  install   i   <dir>   Install package."
  print "  uninstall rm  <name>  Uninstall package."
  print "  list      ls          List installed packages."
  print ""
  print "  Furethermore, each command may contain additional options. For  instance  one"
  print "  can check --help for any command to, probably, find out more."

let help_help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} help [OPTIONS]"
  print ""
  print "\e[1mOPTIONS:\e[0m"
  print "  --help   -h             Show this message."
  print$"  --dev                   Show help for the library developper. It will display\n" ++
        "                          information about installation procedure and  how  to\n" ++
        "                          set up your library so that  it  could  be  installed\n" ++
        "                          with this script."

let help_dev! =
  let text = {TEXT|
In  order to  make library  installable  by the  Dope  it may  be supplied  with
appropriate steering  which will contain  information on all files  required for
the library dependencies, entry point, and routines responsible for building the
library.

Libraries are installed in the directory:

  |TEXT} ++ module_path ++ {TEXT|/<lib-name>

where the first part of the path is obtained a "<ether-prefix>/lib/ether" (check
\`$ ether --prefx\`). And template tree of the directory <lib-name> is:

                <lib-name>
                ├── __main__.[eth|so] -> <entry-point>
                ├── <entry-point>
                ├── ... all other files specified in steering

Sterring is  to be provided  via a script "<lib-root>/install.eth".  It provides
configuration via a  public variables. Following is the list  of variables to be
provided:

  - \e[4mname\e[0m: String with the name of the library. In order to make the name  flexi-
    ble wrt. capital letters this value should be written in lower-case.  If  it
    contains upper-case characters then only exact  match  of  names will work.

  - \e[4mmain\e[0m: Path to the entry point to the library. May be either a script wriiten
    in Ether, or a shared library.

  - \e[4mfiles\e[0m (optional): Listh with pathes to all the other supplementary files re-
    quired by the library. All these files will be copied  to  the  installation
    root (directory previously referenced with <lib-name>).

  - \e[4mbuild\e[0m (optional): Function  of zero  arguments to be called to  build  (i.e.
    compile) the library.

  - \e[4mpost_install\e[0m (optional): Function of zero arguments to be called to clean up
    after the installation.  E.g. one may remove all object files  and  compiled
    library itself.

Installation script will  be evaluated within the root directory  of the library
(the one passed  to the Dope). Command-line arguments provided  by the user will
be available via the \`command_line\`-variable; and  the root directory -- via the
\`root\`-variable.
|TEXT}
  system "LESS=-FX /usr/bin/less -R <<TEXT{text}TEXT"

let install_help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} install [OPTIONS] [<command_line> ...]"
  print ""
  print "\e[1mOPTIONS:\e[0m"
  print "  --help   -h             Show this message."


--------------------------------- Main -----------------------------------------
when List.len command_line < 2 then
  help!
  exit 1

let dopepath :: cmd :: command_line = command_line
--try
if cmd eq "help" || cmd eq "h" then
  let options =
    [
      { name = "dev", val = "dev", has_arg = false },
      { name = "help", val = "help", has_arg = false },
      { name = "h", val = "help", has_arg = false }
    ]
  let opts, _ = CmdArg.get options command_line

  if List.assoc_opt "help" opts then help_help!
  else if List.assoc_opt "dev" opts then help_dev!
  else help!

else if cmd eq "list" || cmd eq "ls" || cmd eq "l" then
  list_modules!

else if cmd eq "install" || cmd eq "i" then
  let options =
    [
      { name = "help", val = "help", has_arg = false },
      { name = "h", val = "help", has_arg = false }
    ]
  let opts, args = CmdArg.get options command_line

  if List.assoc_opt "help" opts then
    install_help!
  else
    -- - - - - - - - - - - - - - - - - - - - --
    -- Install module from a git repository  --
    -- - - - - - - - - - - - - - - - - - - - --
    if let url :: modargs = args then
      -- URL may be a local path. In this case we need it to be a full path
      -- to be able to clone from the temporary directory.
      let url = Os.realpath url if exist? url else url

      -- Check if repository exists.
      unless system "git ls-remote -h '{url}' &>/dev/null" == 0 then
        eprint "> error: \"{url}\" is not a git repository"
        exit 1

      -- Name of the temporary directory where to clone the repo.
      let tmpdir = "dir"

      -- Load database with all installed modules.
      let db = DB.(load default_path)

      -- Clone repository to a temporary directory. There we will build it and
      -- probably install.
      let modentry = do_in_tempdir $ fn ->
        unless system "git clone '{url}' '{tmpdir}'" == 0 then
          eprint "> error: failed to clone repository"
          exit 1

        let version =
          let versions = ModuleInfo.get_versions tmpdir
          if versions is [] then
            print "> module does not have any releases"
            if confirm? "> install from the latest commit (yes/no): " then
              Commit (shell "cd {tmpdir}; git rev-parse HEAD" |> chop)
            else
              print "> exiting then"
              exit 0
          else
            print "> available versions of the module: {versions}"
            when car versions not eq chop (shell "cd {tmpdir}; git describe --tags") then
              unless system "cd {tmpdir}; git checkout {car versions}" == 0 then
                eprint "> error: failed to checkout lates version-tag"
                exit 1
            Tag (car versions)

        print "> installing {version}"

        let modentry = DBEntry.{empty with repository = url, version}
        let conf = ModuleInfo.load_config tmpdir modargs
        Install.build_and_install {modentry, conf, db, dir = tmpdir, args = modargs}

      -- Update registry
      print "> updating registry"
      (db:add modentry):update

    else -- let url :: modargs = agrs
      eprint "> error: missing module-directory path"
      eprint "> see `{basename dopepath} install --help`"
      exit 1

else if cmd eq "uninstall" || cmd eq "rm" then
  let options =
    [
      { name = "help", val = "help", has_arg = false },
      { name = "h", val = "help", has_arg = false }
    ]
  let opts, args = CmdArg.get options command_line

  if List.assoc_opt "help" opts then
    die "unimplemented"
  else
    let [modname] = args
    uninstall modname

else
  eprint "> error: undefined command, {cmd}"
  eprint "> see `{basename dopepath} help` for avaliable commands"
  exit 1

--with e ->
  --eprint "> failure"
  --exit 1
