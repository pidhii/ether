#!/bin/env ether

open IO in

-- Get direcory containing modules
let module_path =
  let pipe = open_pipe_in "ether --prefix" in
  let line = read_line_of pipe in
  if close pipe /= 0
    then raise Failed_to_resolve_prefix
    else format "%d/lib/ether" (String.chop line)
in

-- Checks whether a file exists in the file system
let exist? path =
  try Os.(access path f_ok)
  with System_error ENOENT -> false
in

let mkdir path =
  unless system "mkdir -vp '%d'" path == 0
    then raise System_error;
in

let copy_file src dst =
  printf "> copy %w -> %w\n" src dst;
  open_in src |> read_file |> write_to (open_out dst)
in

let create_symlink src dst =
  unless system "ln -vs '%d' '%d'" src dst == 0
    then raise System_error;
in

let unlink path =
  unless system "rm -rfv %d" path == 0
    then raise System_error;
in

let unlink_quite path =
  unless system "rm -rf %d" path == 0
    then raise System_error;
in

let utc_date! =
  let pipe = open_pipe_in "date -u +'%x %X'" in
  let line = read_line_of pipe in
  if close pipe /= 0
    then raise System_error
    else String.chop line
in

let realpath path =
  let pipe = open_pipe_in (format "realpath '%d'" path) in
  let line = read_line_of pipe in
  if close pipe /= 0
    then raise System_error
    else String.chop line
in

let elf? path =
  read_of (open_in path) 4 eq "\x7fELF"
in

let db_path = format "%d/__db.eth" module_path in

-- Get registry of installed modules
let load_db! = first $ load db_path if exist? db_path else [] in

-- Get module record
let get_module_opt name db =
  List.find_opt (fn {name = name'} -> String.casecmp name name' == 0) db;
in

let update_db db =
  let dbfile = open_out db_path in
  write_to dbfile (format "%w\n" db);
in

let do_in dir thunk =
  let cwd = Os.getcwd! in
  Os.chdir dir;
  (try thunk!  with e -> Os.chdir cwd; raise e);
  Os.chdir cwd;
in

let do_in_tempdir thunk =
  let cwd = Os.getcwd! in

  let tempdir = Os.mkdtemp "/tmp/dope-tmp.XXXXXX" in
  Os.chdir tempdir;
  let cleanup! =
    unlink_quite tempdir;
    Os.chdir cwd;
  in

  (try thunk! with e -> cleanup!; raise e);
  cleanup!;
in


let install dir args =
  -- Read install configuration
  let (_, conf) =
    try
      let env = create_env [("command_line", args), ("root", dir)] in
      env:load (format "%d/install.eth" dir)
    with _ -> begin
      eprintf "> error: failed to load install-script\n";
      raise Failure;
    end
  in
  let name = List.assoc "name" conf in
  let files = List.assoc "files" conf or [] in
  let main = List.assoc "main" conf in

  -- Open DB with all installed modules
  let db = load_db! in
  -- Check if module name is unique
  when get_module_opt name db then begin
    eprintf "> error: module already present\n";
    raise Failure;
  end;

  -- Build (if build-hook is speciefied)
  when let Some build = List.assoc_opt "build" conf then do_in dir (fn ->
    printf "> building module %d\n" name;
    build!;
  );

  -- Start installation
  printf "> installing module %d\n" name;
  -- Create separate direcory for new module
  let moddir = module_path ++ "/" ++ name in
  mkdir moddir;
  -- Copy module sources
  main::files |> List.iter (file ->
    copy_file (dir ++ "/" ++ file) (moddir ++ "/" ++ file);
  );
  printf "> all files copied\n";

  -- Create symlink to main
  let mainext = ".so" if elf? (dir ++ "/" ++ main) else ".eth" in
  let mainpath = moddir ++ "/__main__" ++ mainext in
  unless exist? mainpath
    then create_symlink (moddir ++ "/" ++ main) mainpath;

  -- Update registry
  printf "> updating registry\n";
  let date = utc_date! or "<undefined>" in
  let source_dir = realpath dir or "<undefined>" in
  let install_dir = realpath moddir or "<undefined>" in
  let db = {name, date, source_dir, install_dir} :: db in
  update_db db;

  when let Some post_install = List.assoc_opt "post_install" conf then
    do_in dir (fn ->
      printf "> running post-install hooks\n";
      post_install!;
    );
in


let uninstall name =
  let db = load_db! in

  if let Some {install_dir} = get_module_opt name db then begin
    -- Remove module directory
    printf "> uninstalling module '%d'\n" name;
    unlink install_dir;
    -- Update registry
    printf "> updating registry\n";
    let db = List.remove (fn {name = name'} -> String.casecmp name' name == 0) db in
    update_db db;
  end else begin
    eprintf "> error: no such module\n";
    raise Failure;
  end
in


let reinstall dir args =
  let (_, conf) =
    try
      let env = create_env [("command_line", args), ("root", dir)] in
      env:load (format "%d/install.eth" dir)
    with Failure ->
      eprintf "> error: failed to load install-script\n";
      raise Failure;
  in
  let name = List.assoc "name" conf in
  uninstall name;
  install dir args;
in


let list_modules! =
  let db = load_db! in
  if db is [] then
    printf "> no installed modules\n"
  else
    let f isfirst {name, date, source_dir, install_dir} =
      unless isfirst then print "";
      printf "\e[4mname\e[0m: %d\n" name;
      printf "\e[4msource_dir\e[0m: %d\n" source_dir;
      printf "\e[4minstall_dir\e[0m: %d\n" install_dir;
      printf "\e[4mdate\e[0m: %d\n" date;
      false;
    in List.fold_left f true db
in


let basename path =
  let [_, tail] = String.match \\/?([^\/]+)$/ path in
  tail
in

let help! =
  print "\e[1mUSAGE:\e[0m";
  printf"  %d COMMAND [OPTIONS]\n" (basename $ car command_line);
  print "";
  print "\e[1mCOMMANDS:\e[0m";
  print "  help       h          Show this message.";
  print "  install    i  <dir>   Install package.";
  print "  uninstall  u  <name>  Uninstall package.";
  print "  reinstall  r  <dir>   Reinstall package.";
  print "  list  ls   l          List installed packages.";
  print "";
  print "  Furethermore, each command may contain additional options. For  instance  one";
  print "  can check --help for any command to, probably, find out more.";
in

let help_help! =
  print "\e[1mUSAGE:\e[0m";
  printf"  %d help [OPTIONS]\n" (basename $ car command_line);
  print "";
  print "\e[1mOPTIONS:\e[0m";
  print "  --help   -h             Show this message.";
  print$"  --dev                   Show help for the library developper. It will display\n"
      ++"                          information about installation procedure and  how  to\n"
      ++"                          set up your library so that  it  could  be  installed\n"
      ++"                          with this script.";
in

let help_dev! =
  let text = {TEXT|
In order to make library installable by  the Dope it may be supplied with appro-
priate steering which will contain information on  all files  required  for  the
library dependencies, entry point,  and routines responsible  for  building  the
library.

Libraries are installed in the directory:

  |TEXT} ++ module_path ++ {TEXT|/<lib-name>

where  the first part  of  the path  is obtained  as  "<ether-prefix>/lib/ether"
(check \`$ ether --prefx\`). And template tree of the directory <lib-name> is:

                <lib-name>
                ├── __main__.[eth|so] -> <entry-point>
                ├── <entry-point>
                ├── ... all other files specified in steering

Sterring is to be provided via a script  "<lib-root>/install.eth".  It  provides
configuration via a public variables. Following is the list of variables  to  be
provided:

  - \e[4mname\e[0m: String with the name of the library. In order to make the name  flexi-
    ble wrt. capital letters this value should be written in lower-case.  If  it
    contains upper-case characters then only exact  match  of  names will work.

  - \e[4mmain\e[0m: Path to the entry point to the library. May be either a script wriiten
    in Ether, or a shared library.

  - \e[4mfiles\e[0m (optional): Listh with pathes to all the other supplementary files re-
    quired by the library. All these files will be copied  to  the  installation
    root (directory previously referenced with <lib-name>).

  - \e[4mbuild\e[0m (optional): Function  of zero  arguments to be called to  build  (i.e.
    compile) the library.

  - \e[4mpost_install\e[0m (optional): Function of zero arguments to be called to clean up
    after the installation.  E.g. one may remove all object files  and  compiled
    library itself.

Installation script will be evaluated within the root directory of  the  library
(the one passed to the Dope).  Command-line arguments provided by the user  will
be available via the \`command_line\`-variable; and the root directory --  via the
\`root\`-variable.
|TEXT}
  in
  system "LESS=-FX /usr/bin/less -R <<TEXT%dTEXT" text;
in

let install_help! =
  print "\e[1mUSAGE:\e[0m";
  printf"  %d install [OPTIONS] [<command_line> ...]\n" (basename $ car command_line);
  print "";
  print "\e[1mOPTIONS:\e[0m";
  print "  --help   -h             Show this message.";
  print "  --git         <url>     Install linbrary from a remote Git repository.";
in


--------------------------------- Main -----------------------------------------
when List.len command_line < 2 then begin
  help!;
  exit 1;
end;

let dopepath :: cmd :: command_line = command_line in
try
  if cmd eq "help" || cmd eq "h" then
    let options =
      [ {name = "dev", val = "dev", has_arg = false}
      , {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, _) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then help_help!
    else if List.assoc_opt "dev" opts then help_dev!
    else help!

  else if cmd eq "list" || cmd eq "ls" || cmd eq "l" then
    list_modules!

  else if cmd eq "install" || cmd eq "i" then
    let options =
      [ {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      , {name = "git", val = "git", has_arg = false}
      ]
    in
    let (opts, args) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then install_help!
    else if List.assoc_opt "git" opts then
      if let url :: modargs = args then
        let reponame =
          if let [_, x] = String.match \\/([^\/]+).git$/ url then x
          else if let [_, x] = String.match \\/([^\/]+)$/ url then x
          else "__repository__"
        in
        do_in_tempdir (fn ->
          if system "git clone %d %d" url reponame /= 0 then begin
            eprintf "> error: failed to clone repository\n";
            exit 1;
          end else
            install reponame modargs
        )
      else begin
        eprintf "> error: missing module-directory path\n";
        eprintf "> see `%d install --help`\n" (basename dopepath);
        exit 1;
      end
    else
      if let moddir :: modargs = args then install moddir modargs
      else begin
        eprintf "> error: missing module-directory path\n";
        eprintf "> see `%d install --help`\n" (basename dopepath);
        exit 1;
      end

  else if cmd eq "uninstall" || cmd eq "u" then
    let options =
      [ {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, args) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then die "unimplemented"
    else
      let [modname] = args in
      uninstall modname

  else if cmd eq "reinstall" || cmd eq "r" then
    let options =
      [ {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, args) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then die "unimplemented"
    else
      let modname :: modargs = args in
      reinstall modname modargs

  else begin
    eprintf "> error: undefined command, %w\n" cmd;
    eprintf "> see `%d help` for avaliable commands\n" (basename dopepath);
    exit 1;
  end

with e -> begin
  eprintf "> failure\n";
  exit 1;
end;

