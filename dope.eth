#!/bin/env ether

open IO in
open String (chop, chomp, split, match, to_number) in
open List (map, rev_filter_map, sort) in

module Utl =
  -- Get direcory containing modules
  let pub module_path =
    let pipe = open_pipe_in "ether --prefix" in
    let prefix = IO.read_line_of pipe |> String.chop in
    if close pipe /= 0
      then raise Failed_to_resolve_prefix
      else prefix ++ "/lib/ether"

  -- Checks whether a file exists in the file system
  let pub exist? path =
    try Os.(access path f_ok)
    with System_error ENOENT -> false

  let pub mkdir path =
    unless system "mkdir -vp '{path}'" == 0
      then raise System_error

  let pub copy_file src dst =
    print "> copy \"{src}\" -> \"{dst}\"";
    open_in src |> IO.read_file |> IO.write_to (open_out dst)

  let pub create_symlink src dst =
    unless system "ln -vs '{src}' '{dst}'" == 0
      then raise System_error

  let pub unlink path =
    unless system "rm -rfv '{path}'" == 0
      then raise System_error

  let pub unlink_quite path =
    unless system "rm -rf '{path}'" == 0
      then raise System_error

  let pub utc_date! =
    let pipe = open_pipe_in "date -u +'%x %X'" in
    let line = IO.read_line_of pipe in
    if close pipe /= 0
      then raise System_error
      else String.chop line

  let pub elf? path = IO.read_of (open_in path) 4 eq "\x7fELF"

  let pub do_in dir thunk =
    let cwd = Os.getcwd! in
    Os.chdir dir;
    (try thunk!  with e -> Os.chdir cwd; raise e);
    Os.chdir cwd

  let pub do_in_tempdir thunk =
    let cwd = Os.getcwd! in

    let tempdir = Os.mkdtemp "/tmp/dope-tmp.XXXXXX" in
    Os.chdir tempdir;
    let cleanup! =
      unlink_quite tempdir;
      Os.chdir cwd;
    in

    let thunk_result = (try thunk! with e -> cleanup!; raise e) in
    cleanup!;
    thunk_result


  let rec pub confirm? x =
    if let (prompt1, prompt2) = x then
      let rec loop ans =
        if ans =~ \[Yy](es)?/ then true
        else if ans =~ \[Nn]o?/ then false
        else loop (input prompt2)
      in
      loop (input prompt1)
    else
      confirm? (x, "> try again (yes/no): ")
end;
open Utl in


module DB =
  open Utl
  using String as S
  using List as L

  let pub default_path = module_path ++ "/__db.eth"

  -- Get registry of installed modules
  let pub load path =
    { db = first $ load path if exist? path else []
    , path

    -- Get module record
    , get_module_opt = fn {db} name ->
      L.find_opt (fn {name = name'} -> S.casecmp name name' == 0) db

    , remove = fn ({db} as self) name ->
      {self with
        db = L.remove (fn {name = name'} -> S.casecmp name' name == 0) db
      }

    , add = fn ({db} as self) entry ->
      {self with db = entry :: db}

    , update = fn {db, path} ->
        let dbfile = open_out path in
        IO.write_to dbfile (format "%w\n" db)
    }
end;


module ModuleInfo =
  using String as S
  using List as L

  let pub get_versions repodir =
    -- Get all tags
    IO.shell "cd {repodir}; git tag" |> S.chop |> S.split \\s+/
    -- Decode version-tags into major, minor and a patch.
    |> L.rev_filter_map (fn tag ->
      if let [_, major, minor, patch] = S.match \([0-9]+)\.([0-9]+)\.([0-9]+)/ tag then
        (tag, L.map S.to_number [major, minor, patch])
      else raise Filter_out
    )
    -- Sort versions.
    |> L.sort (fn (_, a) (_, b) ->
      let rec loop xs ys =
        if let x :: xs' = xs then
          if let y :: ys' = ys then
            if x > y then true
            else x == y && loop xs' ys'
          else true
        else true
      in
      loop a b
    )
    |> L.map first

  let pub load_config dir args =
    let (_, conf) =
      try
        let env = create_env [("command_line", args), ("root", dir)] in
        env:load (dir ++ "/install.eth")
      with _ ->
        eprint "> error: failed to load install-script";
        raise Failure
    in
    { name = L.assoc "name" conf
    , files = L.assoc "files" conf or []
    , main = L.assoc "main" conf
    , build = L.assoc_opt "build" conf
    , post_install = L.assoc_opt "post_install" conf
    }
end;


module DBEntry =
  let pub empty = {
    name = nil,
    date = nil,
    install_dir = nil,
    repository = nil,
    version = nil,
  }
end;


module Install =
  open Utl
  using List as L
  using String as S

  let pub build_and_install {conf, modentry, db, dir, args} =
    let {name, files, main, build, post_install} = conf in

    -- Check if module name is unique
    print name;
    when db:get_module_opt name then begin
      eprint "> error: module already present";
      raise Failure;
    end;

    -- Build (if build-hook is speciefied)
    when let Some build = build then do_in dir (fn ->
      print "> building module {name}";
      build!;
    );

    -- Start installation
    print "> installing module {name}";
    -- Create separate direcory for new module
    let moddir = module_path ++ "/" ++ name in
    mkdir moddir;
    -- Copy module sources
    main::files |> L.iter (file ->
      copy_file (dir ++ "/" ++ file) (moddir ++ "/" ++ file);
    );
    print "> all files copied";

    -- Create symlink to main
    let mainext = ".so" if elf? (dir ++ "/" ++ main) else ".eth" in
    let mainpath = moddir ++ "/__main__" ++ mainext in
    unless exist? mainpath
      then create_symlink (moddir ++ "/" ++ main) mainpath;

    when let Some post_install = post_install then
      do_in dir (fn ->
        print "> running post-install hooks";
        post_install!;
      );

    {modentry with
      name,
      date = utc_date! or "<undefined>",
      install_dir = Os.realpath moddir or "<undefined>",
    }
end;


let uninstall name =
  let db = DB.(load default_path) in

  if let Some {install_dir} = db:get_module_opt name then begin
    -- Remove module directory
    print "> uninstalling module '{name}'";
    unlink install_dir;
    -- Update registry
    print "> updating registry";
    let db = db:remove name in
    db:update
  end else begin
    eprint "> error: no such module";
    raise Failure;
  end
in


let list_modules! =
  let {db} = DB.(load default_path) in
  if db is [] then
    print "> no installed modules"
  else
    let f isfirst modentry =
      print "" unless isfirst;
      list modentry |> List.iter (fn (k, v) ->
        print "\e[4m{k}\e[0m: {v}"
      );
      false;
    in List.fold_left f true db
in


let basename path =
  let [_, tail] = String.match \\/?([^\/]+)$/ path in
  tail
in

let help! =
  print "\e[1mUSAGE:\e[0m";
  print "  {basename $ car command_line} COMMAND [OPTIONS]";
  print "";
  print "\e[1mCOMMANDS:\e[0m";
  print "  help      h           Show this message.";
  print "  install   i   <dir>   Install package.";
  print "  uninstall rm  <name>  Uninstall package.";
  print "  list      ls          List installed packages.";
  print "";
  print "  Furethermore, each command may contain additional options. For  instance  one";
  print "  can check --help for any command to, probably, find out more.";
in

let help_help! =
  print "\e[1mUSAGE:\e[0m";
  print "  {basename $ car command_line} help [OPTIONS]";
  print "";
  print "\e[1mOPTIONS:\e[0m";
  print "  --help   -h             Show this message.";
  print$"  --dev                   Show help for the library developper. It will display\n"
      ++"                          information about installation procedure and  how  to\n"
      ++"                          set up your library so that  it  could  be  installed\n"
      ++"                          with this script.";
in

let help_dev! =
  let text = {TEXT|
In order to make library installable by  the Dope it may be supplied with appro-
priate steering which will contain information on  all files  required  for  the
library dependencies, entry point,  and routines responsible  for  building  the
library.

Libraries are installed in the directory:

  |TEXT} ++ module_path ++ {TEXT|/<lib-name>

where  the first part  of  the path  is obtained  as  "<ether-prefix>/lib/ether"
(check \`$ ether --prefx\`). And template tree of the directory <lib-name> is:

                <lib-name>
                ├── __main__.[eth|so] -> <entry-point>
                ├── <entry-point>
                ├── ... all other files specified in steering

Sterring is to be provided via a script  "<lib-root>/install.eth".  It  provides
configuration via a public variables. Following is the list of variables  to  be
provided:

  - \e[4mname\e[0m: String with the name of the library. In order to make the name  flexi-
    ble wrt. capital letters this value should be written in lower-case.  If  it
    contains upper-case characters then only exact  match  of  names will work.

  - \e[4mmain\e[0m: Path to the entry point to the library. May be either a script wriiten
    in Ether, or a shared library.

  - \e[4mfiles\e[0m (optional): Listh with pathes to all the other supplementary files re-
    quired by the library. All these files will be copied  to  the  installation
    root (directory previously referenced with <lib-name>).

  - \e[4mbuild\e[0m (optional): Function  of zero  arguments to be called to  build  (i.e.
    compile) the library.

  - \e[4mpost_install\e[0m (optional): Function of zero arguments to be called to clean up
    after the installation.  E.g. one may remove all object files  and  compiled
    library itself.

Installation script will be evaluated within the root directory of  the  library
(the one passed to the Dope).  Command-line arguments provided by the user  will
be available via the \`command_line\`-variable; and the root directory --  via the
\`root\`-variable.
|TEXT}
  in
  system "LESS=-FX /usr/bin/less -R <<TEXT{text}TEXT";
in

let install_help! =
  print "\e[1mUSAGE:\e[0m";
  print "  {basename $ car command_line} install [OPTIONS] [<command_line> ...]";
  print "";
  print "\e[1mOPTIONS:\e[0m";
  print "  --help   -h             Show this message.";
in


--------------------------------- Main -----------------------------------------
when List.len command_line < 2 then begin
  help!;
  exit 1;
end;

let dopepath :: cmd :: command_line = command_line in
try
  if cmd eq "help" || cmd eq "h" then
    let options =
      [ {name = "dev", val = "dev", has_arg = false}
      , {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, _) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then help_help!
    else if List.assoc_opt "dev" opts then help_dev!
    else help!

  else if cmd eq "list" || cmd eq "ls" || cmd eq "l" then
    list_modules!

  else if cmd eq "install" || cmd eq "i" then
    let options =
      [ {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, args) = CmdArg.get options command_line in

    if List.assoc_opt "help" opts then
      install_help!
    else
      -- - - - - - - - - - - - - - - - - - - - --
      -- Install module from a git repository  --
      -- - - - - - - - - - - - - - - - - - - - --
      if let url :: modargs = args then begin
        -- URL may be a local path. In this case we need it to be a full path
        -- to be able to clone from the temporary directory.
        let url = Os.realpath url if exist? url else url in

        -- Check if repository exists.
        unless system "git ls-remote -h '{url}' &>/dev/null" == 0 then begin
          eprint "> error: \"{url}\" is not a git repository";
          exit 1;
        end;

        -- Name of the temporary directory where to clone the repo.
        let tmpdir = "dir" in

        -- Load database with all installed modules.
        let db = DB.(load default_path) in

        -- Clone repository to a temporary directory. There we will build it and
        -- probably install.
        let modentry = do_in_tempdir $ fn ->
          unless system "git clone '{url}' '{tmpdir}'" == 0 then begin
            eprint "> error: failed to clone repository";
            exit 1;
          end;

          let version =
            let versions = ModuleInfo.get_versions tmpdir in
            if versions is [] then begin
              print "> module does not have any releases";
              if confirm? "> install from the latest commit (yes/no): "
                then Commit (shell "cd {tmpdir}; git rev-parse HEAD" |> chop)
                else (print "> exiting then"; exit 0);
            end else begin
              print "> available versions of the module: {versions}";
              when car versions not eq chop (shell "cd {tmpdir}; git describe --tags") then
                unless system "cd {tmpdir}; git checkout {car versions}" == 0 then begin
                  eprint "> error: failed to checkout lates version-tag";
                  exit 1;
                end;
              Tag (car versions)
            end
          in
          print "> installing {version}";

          let modentry = DBEntry.{empty with repository = url, version} in
          let conf = ModuleInfo.load_config tmpdir modargs in
          Install.build_and_install {modentry, conf, db, dir = tmpdir, args = modargs}
        in

        -- Update registry
        print "> updating registry";
        (db:add modentry):update

      end else begin -- let url :: modargs = agrs
        eprint "> error: missing module-directory path";
        eprint "> see `{basename dopepath} install --help`";
        exit 1;
      end

  else if cmd eq "uninstall" || cmd eq "rm" then
    let options =
      [ {name = "help", val = "help", has_arg = false}
      , {name = "h", val = "help", has_arg = false}
      ]
    in
    let (opts, args) = CmdArg.get options command_line in
    if List.assoc_opt "help" opts then die "unimplemented"
    else
      let [modname] = args in
      uninstall modname

  else begin
    eprint "> error: undefined command, {cmd}";
    eprint "> see `{basename dopepath} help` for avaliable commands";
    exit 1;
  end

with e ->
  eprint "> failure";
  exit 1;
