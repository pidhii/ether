#!/bin/env ether

open IO
open String (chomp, split, match, to_number)
open List (map, rev_filter_map, sort)


module Logging =
  let pub paint text =
    "\e[48;5;232;38;5;231m{text}\e[0m"

  let pub info msg =
    print $ paint " {msg} "

  let pub error msg =
    eprint "\e[48;5;196;38;5;232;1mdope-error\e[0m\e[48;5;232;38;5;231m:{paint " {msg} "}"

  let pub fatal_error msg =
    error msg
    exit 1

open Logging


module Utl =
  open Logging

  -- Get direcory containing modules
  let pub module_path =
    let pipe = open_pipe_in "ether --prefix"
    let prefix = IO.read_line_of pipe |> String.chomp
    if close pipe /= 0
    then raise Failed_to_resolve_prefix
    else prefix ++ "/lib/ether"

  -- Checks whether a file exists in the file system
  let pub exist? path =
    try Os.(access path f_ok)
    with System_error ENOENT -> false

  let pub mkdir path =
    unless system "mkdir -vp '{path}'" == 0
    then raise System_error

  let pub copy_file src dst =
    info "copy \"{src}\" -> \"{dst}\""
    open_in src |> IO.read_file |> IO.write_to (open_out dst)

  let pub create_symlink src dst =
    unless system "ln -vs '{src}' '{dst}'" == 0
    then raise System_error

  let pub unlink path =
    unless system "rm -rfv '{path}'" == 0
    then raise System_error

  let pub unlink_quite path =
    unless system "rm -rf '{path}'" == 0
    then raise System_error

  let pub utc_date! =
    let pipe = open_pipe_in "date -u +'%x %X'"
    let line = IO.read_line_of pipe
    if close pipe /= 0
    then raise System_error
    else String.chomp line

  let pub elf? path = IO.read_of (open_in path) 4 eq "\x7fELF"

  let pub do_in dir thunk =
    let cwd = Os.getcwd!
    Os.chdir dir
    try
      thunk!
    with e ->
      Os.chdir cwd
      raise e
    Os.chdir cwd

  let pub do_in_tempdir thunk =
    let cwd = Os.getcwd!

    let tempdir = Os.mkdtemp "/tmp/dope-XXXXXX"
    Os.chdir tempdir
    let cleanup! =
      unlink_quite tempdir
      Os.chdir cwd

    let thunk_result = try thunk! with e -> cleanup!; raise e
    cleanup!
    thunk_result


  let rec pub confirm? x =
    if let (prompt1, prompt2) = x then
      let rec loop ans =
        if ans =~ \[Yy](es)?/ then true
        else if ans =~ \[Nn]o?/ then false
        else loop (input prompt2)
      loop (input prompt1)
    else
      confirm? (x, paint " try again (yes/no): ")

open Utl


module DB =
  open Utl
  using String as S
  using List as L

  let pub default_path = module_path ++ "/__db.eth"

  -- Get registry of installed modules
  let pub load path =
    { db = (first $ load path) if exist? path else []
    , path
    , get_module_opt = {db} name ->
        L.find_opt ({name = name'} -> S.casecmp name name' == 0) db
    , remove = fn ({db} as self) name ->
        {self with
          db = L.remove ({name = name'} -> S.casecmp name' name == 0) db
        }
    , add = fn ({db} as self) entry ->
        {self with db = entry :: db}
    , update = {db, path} ->
        let dbfile = open_out path
        IO.write_to dbfile (format "%w\n" db)
    }

module Git =
  let pub repository? url =
    system "git ls-remote -h '{url}' &>/dev/null" == 0

  let pub clone url dir =
    unless system "git clone '{url}' '{dir}'" == 0 then raise Failure
    { dir
    , current_commit = {dir} ->
        IO.shell "cd {dir}; git rev-parse HEAD"
    , current_tag = {dir} ->
        IO.shell "cd {dir}; git describe --tags"
    , checkout = {dir} commit ->
        unless system "cd {dir}; git checkout {commit}" == 0
        then raise Failure
    }


module GitHub =
  let pub search_repositories tgt_name =
    let ans =
      IO.shell "curl -s 'https://api.github.com/search/repositories?q={tgt_name}'"
      |> Json.parse

    let total_count = List.assoc "total_count" ans

    open List
    assoc "items" ans
    -- Build items into more practical structure.
    |> map $ repo ->
      let name = assoc "name" repo
      let full_name = assoc "full_name" repo
      let clone_url = assoc "clone_url" repo
      let description = assoc "description" repo
      {name, full_name, clone_url, description}
    -- Remove items with name mismatch
    |> filter $ {name} -> name eq tgt_name


module ModuleInfo =
  open Logging

  using String as S
  using List as L

  let pub get_versions repodir =
    -- Get all tags
    IO.shell "cd {repodir}; git tag" |> S.chomp |> S.split \\s+/
    -- Decode version-tags into major, minor and a patch.
    |> L.rev_filter_map $ tag ->
      if let [_, major, minor, patch] = S.match \([0-9]+)\.([0-9]+)\.([0-9]+)/ tag then
        (tag, L.map S.to_number [major, minor, patch])
      else raise Filter_out
    -- Sort versions.
    |> L.sort $ (_, a) (_, b) ->
      let rec loop xs ys =
        if let x :: xs' = xs then
          if let y :: ys' = ys then
            if x > y then true
            else x == y && loop xs' ys'
          else true
        else true
      loop a b
    |> L.map first

  let pub load_config dir args =
    let _, conf =
      try
        let env = create_env [("command_line", args), ("root", dir)]
        env:load (dir ++ "/install.eth")
      with _ ->
        error "failed to load install-script"
        raise Failure
    { name = L.assoc "name" conf
    , files = L.assoc "files" conf or []
    , main = L.assoc "main" conf
    , build = L.assoc_opt "build" conf
    , post_install = L.assoc_opt "post_install" conf
    }


module DBEntry =
  let pub empty = {
    name = nil,
    date = nil,
    install_dir = nil,
    repository = nil,
    version = nil,
  }


module Install =
  open Logging
  open Utl

  using List as L
  using String as S

  let pub build_and_install {conf, modentry, db, dir, args} =
    let {name, files, main, build, post_install} = conf

    -- Check if module name is unique
    print name
    when db:get_module_opt name then
      error "module already present"
      raise Failure

    -- Build (if build-hook is speciefied)
    when let Some build = build then do_in dir $ fn ->
      info "building module {name}"
      build!

    -- Start installation
    info "installing module {name}"
    -- Create separate direcory for new module
    let moddir = module_path ++ "/" ++ name
    mkdir moddir
    -- Copy module sources
    main::files |> L.iter $ file ->
      copy_file (dir ++ "/" ++ file) (moddir ++ "/" ++ file)

    info "module is ready for use"

    -- Create symlink to main
    let mainext = ".so" if elf? (dir ++ "/" ++ main) else ".eth"
    let mainpath = moddir ++ "/__main__" ++ mainext
    unless exist? mainpath then
      create_symlink (moddir ++ "/" ++ main) mainpath

    when let Some post_install = post_install then do_in dir $ fn ->
      info "running post-install hooks"
      post_install!

    { modentry with name,
        date = utc_date! or "<undefined>",
        install_dir = Os.realpath moddir or "<undefined>",
    }


let uninstall name =
  let db = DB.(load default_path)

  if let Some {install_dir} = db:get_module_opt name then
    -- Remove module directory
    info "uninstalling module '{name}'"
    unlink install_dir
    -- Update registry
    info "updating registry"
    let db = db:remove name
    db:update
  else
    error "no such module"
    raise Failure


let list_modules! =
  let {db} = DB.(load default_path)
  if db is [] then
    info "no installed modules"
  else
    let f isfirst modentry =
      print "" unless isfirst
      list modentry |> List.iter $ (k, v) ->
        print "\e[4m{k}\e[0m: {v}"
      false
    List.fold_left f true db


let basename path =
  let [_, tail] = String.match \\/?([^\/]+)$/ path
  tail

let help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} COMMAND [OPTIONS]"
  print ""
  print "\e[1mCOMMANDS:\e[0m"
  print "  help      h           Show this message."
  print "  install   i   <dir>   Install package."
  print "  uninstall rm  <name>  Uninstall package."
  print "  list      ls          List installed packages."
  print ""
  print "  Furethermore, each command may contain additional options. For  instance  one"
  print "  can check --help for any command to, probably, find out more."

let help_help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} help [OPTIONS]"
  print ""
  print "\e[1mOPTIONS:\e[0m"
  print "  --help   -h             Show this message."
  print$"  --dev                   Show help for the library developper. It will display\n" ++
        "                          information about installation procedure and  how  to\n" ++
        "                          set up your library so that  it  could  be  installed\n" ++
        "                          with this script."

let help_dev! =
  let text = {TEXT|
In  order to  make library  installable  by the  Dope  it may  be supplied  with
appropriate steering  which will contain  information on all files  required for
the library dependencies, entry point, and routines responsible for building the
library.

Libraries are installed in the directory:

  |TEXT} ++ module_path ++ {TEXT|/<lib-name>

where the first part of the path is obtained a "<ether-prefix>/lib/ether" (check
\`$ ether --prefx\`). And template tree of the directory <lib-name> is:

                <lib-name>
                ├── __main__.[eth|so] -> <entry-point>
                ├── <entry-point>
                ├── ... all other files specified in steering

Sterring is  to be provided  via a script "<lib-root>/install.eth".  It provides
configuration via a  public variables. Following is the list  of variables to be
provided:

  - \e[4mname\e[0m: String with the name of the library. In order to make the name  flexi-
    ble wrt. capital letters this value should be written in lower-case.  If  it
    contains upper-case characters then only exact  match  of  names will work.

  - \e[4mmain\e[0m: Path to the entry point to the library. May be either a script wriiten
    in Ether, or a shared library.

  - \e[4mfiles\e[0m (optional): Listh with pathes to all the other supplementary files re-
    quired by the library. All these files will be copied  to  the  installation
    root (directory previously referenced with <lib-name>).

  - \e[4mbuild\e[0m (optional): Function  of zero  arguments to be called to  build  (i.e.
    compile) the library.

  - \e[4mpost_install\e[0m (optional): Function of zero arguments to be called to clean up
    after the installation.  E.g. one may remove all object files  and  compiled
    library itself.

Installation script will  be evaluated within the root directory  of the library
(the one passed  to the Dope). Command-line arguments provided  by the user will
be available via the \`command_line\`-variable; and  the root directory -- via the
\`root\`-variable.
|TEXT}
  system "LESS=-FX /usr/bin/less -R <<TEXT{text}TEXT"

let install_help! =
  print "\e[1mUSAGE:\e[0m"
  print "  {basename $ car command_line} install [OPTIONS] [<command_line> ...]"
  print ""
  print "\e[1mOPTIONS:\e[0m"
  print "  --help   -h             Show this message."


--------------------------------- Main -----------------------------------------
when List.len command_line < 2 then
  help!
  exit 1

let dopepath :: cmd :: command_line = command_line
try
  if cmd eq "help" || cmd eq "h" then
    let options =
      [
        { name = "dev", val = "dev", has_arg = false },
        { name = "help", val = "help", has_arg = false },
        { name = "h", val = "help", has_arg = false }
      ]
    let opts, _ = CmdArg.get options command_line

    if List.assoc_opt "help" opts then help_help!
    else if List.assoc_opt "dev" opts then help_dev!
    else help!

  else if cmd eq "list" || cmd eq "ls" || cmd eq "l" then
    list_modules!

  else if cmd eq "install" || cmd eq "i" then
    let options =
      [
        { name = "help", val = "help", has_arg = false },
        { name = "h", val = "help", has_arg = false }
      ]
    let opts, args = CmdArg.get options command_line

    if List.assoc_opt "help" opts then
      install_help!
    else
      -- - - - - - - - - - - - - - - - - - - - --
      -- Install module from a git repository  --
      -- - - - - - - - - - - - - - - - - - - - --
      if let url :: modargs = args then
        let url =
          -- URL may be a local path. In this case we need it to be a full path
          -- to be able to clone from the temporary directory.
          if exist? url then Os.realpath url else
            -- Resolve repository path.
            if Git.repository? url then url else
              -- Not a valied URL. Search on GitHub.
              let github_matches =
                try GitHub.search_repositories url
                with _ -> fatal_error "\"{url}\" is not a git repository"

              if let [github_repo] = github_matches then
                -- Single match! Perfect!
                info "found GitHub repository: {github_repo.full_name}"
                github_repo.clone_url
              else if github_matches is [] then
                -- No matches
                fatal_error "\"{url}\" is not a git repository"
              else
                -- Multiple matches. Have to select only a single one of these.
                info "multiple repositories match the name, select one to install:"
                do_in_tempdir $ fn ->
                  let tmp = open_out "list"
                  github_matches |> List.iter $ github_repo ->
                    write_to tmp github_repo.full_name

                  let ans = shell {q|select x in $(cat list) Cancel; do test -n "$x" && break; done; echo $x|q}
                  if ans eq "" || ans eq "Cancel"
                  then info "exiting then"; exit 0
                  else (List.find (x -> x:full_name eq ans) github_matches).clone_url

        -- Load database with all installed modules.
        let db = DB.(load default_path)

        -- Clone repository to a temporary directory. There we will build it and
        -- probably install.
        let modentry = do_in_tempdir $ fn ->
          let git_repo =
            try Git.clone url "dir"
            with Failure -> fatal_error "failed to clone repository"

          -- Figure out a version of the module to use. If version-tags
          -- available will install the latest version. Otherwize, use latest
          -- commit in the repository.
          let version =
            let versions = ModuleInfo.get_versions git_repo.dir
            if versions is [] then
              -- No releases available. Try to install from the latest commit
              -- if user accepts it.
              info "module does not have any releases"
              if confirm? (paint " install from the latest commit (yes/no): ")
              then Commit git_repo:current_commit
              else info "exiting then"; exit 0
            else
              -- Will use latest version. Check if current commit corresponds to
              -- the latest version, if not - checkout desired commit.
              info "available versions of the module: {versions}"
              let latest = car versions
              when git_repo:current_tag not eq latest then
                try git_repo:checkout latest
                with Failure -> fatal_error "failed to checkout '{latest}'"
              Tag latest

          info "installing {version}"

          let modentry = DBEntry.{empty with repository = url, version}
          let conf = ModuleInfo.load_config git_repo.dir modargs
          Install.build_and_install {modentry, conf, db, dir = git_repo.dir, args = modargs}

        -- Update registry
        info "updating registry"
        (db:add modentry):update

      else -- let url :: modargs = agrs
        error "missing module-directory path"
        info "see `{basename dopepath} install --help`"
        exit 1

  else if cmd eq "uninstall" || cmd eq "rm" then
    let options =
      [
        { name = "help", val = "help", has_arg = false },
        { name = "h", val = "help", has_arg = false }
      ]
    let opts, args = CmdArg.get options command_line

    if List.assoc_opt "help" opts then
      die "unimplemented"
    else
      let [modname] = args
      uninstall modname

  else
    error "undefined command, {cmd}"
    info "see `{basename dopepath} help` for avaliable commands"
    exit 1

with e ->
  exit 1
